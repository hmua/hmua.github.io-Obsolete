
<style>
	textarea { width: 100% }
	.tabs { position: absolute; padding-left:.5em }
		.tabs .newLine {margin-bottom:.5rem; margin-right: 100% }
		.tabs [class^=pluck],.tabs .delay { width: .8rem; text-align:center; line-height: 1rem;display: inline-block;
			 vertical-align: middle;/*å¦‚æœä¸è®¾ç½®è¿™æ¡ï¼Œç”¨paddingè®¾ç½®ç«–å‘ä½ç½®å°±ä¼šå¤±æ•ˆâ€¦â€¦æ„Ÿè§‰æ˜¯bugï¼ˆä½†è¿™ä¸å¯èƒ½å•Šâ€¦â€¦ï¼‰*/
			 text-shadow:-.1em 0 white,.1em 0 white,-.05em 0 white,.05em 0 white,0 -.1em white,0 .1em white,0 -.05em white,0 .05em white}
		.tabs [class^=pluckg] { padding: 3rem 0 0}
		.tabs [class^=pluckc] { padding: 2rem 0 1rem }
		.tabs [class^=plucke] { padding:1rem 0 2rem}
		.tabs [class^=plucka] { padding: 0 0 3rem}
		.tabs [class$="10"],.tabs [class$="11"],.tabs [class$="12"],.tabs [class$="13"],.tabs [class$="14"],.tabs [class$="15"],.tabs [class$="16"],.tabs [class$="17"],.tabs [class$="18"],.tabs [class$="19"],.tabs [class$="20"] { font-size: .6em }

	.tabs { font-family: 'Trebuchet MS'; position: relative;margin:.5em auto;
				 background:repeating-linear-gradient(
					 white,white .9em,silver .9em,silver 1em,
					 white 1em,white 1.9em,silver 1.9em,silver 2em,
					 white 2em,white 2.9em,silver 2.9em,silver 3em,
					 white 3em,white 3.9em,silver 3.9em,silver 4em,
					 white 4em,white 4.5em) 0 -.45em}
	h1::before { content: 'ğŸ¼';color:red }
	html { font-family: 'Microsoft YaHei UI' }
	textarea { height: 5em }
	ol,ul { margin: .5rem }
</style>
<h1>ç”ŸæˆTABs</h1>
<ul>
	<li>Gã€Cã€Eã€Aè¡¨ç¤ºå¼¦å››åˆ°ä¸€ï¼Œæ•°å­—1~9è¡¨ç¤ºå“ä¸€åˆ°ä¹</li>
	<li>é”®ç›˜ç¬¬ä¸€è¡Œé™¤Eä¹‹å¤–çš„â€œQWRTYUIOPâ€è¡¨ç¤ºååŠä»¥ä¸Šå“</li>
	<li>ä¾‹å¦‚â€œG1â€è¡¨ç¤ºGå¼¦ä¸€å“ï¼Œâ€œC7â€è¡¨ç¤ºCå¼¦ä¸ƒå“</li>
	<li>â€œEQâ€Eå¼¦åå“ï¼Œâ€œA0â€Aå¼¦å¼€éŸ³ï¼Œç­‰ç­‰</li>
	<li>é‡å¤å¼¦å¯ä»¥çœç•¥ï¼Œä¾‹å¦‚â€œA0077997â€ä¸ƒä¸ªéŸ³éƒ½æ˜¯Aå¼¦</li>
	<li>å¦‚æœä»æœ€å¼€å§‹å°±ä¸å†™ï¼Œåˆ™é»˜è®¤Aå¼¦</li>
	<li>ç©ºæ‹æˆ–è€…ä¼‘æ­¢ç”¨ç©ºæ ¼</li></ul>
<textarea>c2e3a02c0e0a2230e3a0c0e2a0 &#x00A;c2e23a0c2e2a002&#x00A;c0123e45a6789qwrtyuiop</textarea>
<div class="tabs"></div><ul>
	<li>ç ”å‘åˆæœŸï¼Œæ ¼å¼éšæ—¶è°ƒæ•´ï¼Œéšä¾¿è¯•ç”¨ä¸‹å°±å¥½</li>
	<li>æ²¡æœ‰ä¿å­˜åŠŸèƒ½ï¼Œéœ€è¦è‡ªå·±å¤åˆ¶ä¿å­˜</li>
	<li>å’Œå¼¦è¿˜æ²¡æ”¯æŒï¼ˆä¸‹ä¸€ç‰ˆåŠ å…¥ï¼‰</li>
	<li>åªæ”¯æŒå°¤å…‹é‡Œé‡Œæ ‡å‡†å¼¦GCEAï¼Œæœªæ¥ä¼šæ”¯æŒå…¶å®ƒ</li>
	<li>å¯ä»¥ç”¨æµè§ˆå™¨çš„ç¼©æ”¾åŠŸèƒ½è°ƒæ•´åˆ°æ»¡æ„å¤§å°</li>
	<li>è¾“å…¥æ¡†ä¹Ÿå¯ä»¥æ‹–ä½å³ä¸‹è§’è°ƒæ•´å¤§å°</li></ul>
<span style="color:red;">&#9833;</span>
<span style="color:orange;">&#9837;</span>
<span style="color:yellow;">&#9834;</span>
<span style="color:green;">&#9839;</span>
<span style="color:aqua;">&#9835;</span>
<span style="color:blue;">&#9838;</span>
<span style="color:purple;">&#9836;</span>
<script>
	class Pluck{constructor(string,fret){this.string=string;this.fret=fret}}let pluck=(string,fret)=>new Pluck(string,fret)
	class Delay{}let delay=()=>new Delay()
	class NewLine{}let newLine=()=>new NewLine()
	let parse=(a)=>{
		let char={string:"string",fret:"fret",delay:"delay",newLine:"newLine",startChord:"startChord",endChord:"endChord"}
		//TODOè¿™é‡Œæœ‰ä¸ªâ€¦â€¦é€»è¾‘æ¶æ„é—®é¢˜â€¦â€¦å¸Œæœ›èƒ½æŠŠâ€œæŠ˜è¡Œâ€ç•™åœ¨æ ‡è®°å’Œè¡¨ç°å±‚ï¼Œä¸å‘ä¸‹ä¼ åˆ°æ•°æ®ï¼Œæ€ä¹ˆåšåé¢è¦å°è¯•ä¸€ä¸‹
		///è¯†åˆ«ã€æ ‡è¯†ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬
		let parseText=(a)=>{
			let parseChar=(a)=>{
				let mismatch=Symbol()
				let fret=["0","1","2","3","4","5","6","7","8","9"].includes(a)?parseInt(a):
						a=="q"?10:a=="w"?11:a=="r"?12:a=="t"?13:a=="y"?14:a=="u"?15:a=="i"?16:a=="o"?17:a=="p"?18:mismatch
				let string=["g","c","e","a"].includes(a)?a:mismatch
				let startChord=a=="("?char.startChord:mismatch
				let endChord=a==")"?char.endChord:mismatch
				let delay=a==" "?char.delay:mismatch
				let newLine=a=="\n"?char.newLine:mismatch
				//TODO JSæœ‰æ²¡æœ‰delay executeï¼Ÿï¼Ÿï¼Ÿæˆ–è€…å¯èƒ½æœ¬èº«å°±æ˜¯ï¼Ÿï¼Ÿæ™šäº›å†ç¡®è®¤â€¦â€¦
				return fret!=mismatch?[char.fret,fret]:string!=mismatch?[char.string,string]:
					startChord!=mismatch?[startChord]:endChord!=mismatch?[endChord]:
					delay!=mismatch?[delay]:newLine!=mismatch?[newLine]:null
			}
			return a.split('').map(parseChar)
		}
		///ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬æ”¯æŒçœç•¥é‡å¤å¼¦ï¼Œåœ¨è¿™é‡ŒæŠŠçœç•¥çš„å†…å®¹è¡¥å®Œæ•´
		let reformatOmitContent=(a)=>{
			let defaultString="a"
			let parse=([string,r],[type,value])=>
				type==char.string?[value,r]:
				type==char.fret?[string,r.concat([[string,value]])]:
				type==char.delay?[string,r.concat(delay)]:
				[string,r.concat(delay)]
			let parse2=([string,r],[type,value])=>{
				switch(type){
					case char.string:return[value,r]
					case char.fret:return[string,r.concat(pluck(string,value))]
					case char.delay:return[string,r.concat(delay())]
					default:return[string,r.concat(newLine())]
					}}
			return a.reduce(parse3,k())[1]
			}
		let reformatOmitContent2=(a)=>{
			let defaultString="a"
			class ChordBuilder{constructor(){this.r=[]}
				setString(a){this.string=a}
				setFret(a){r.push[this.string,a]}
				get(){r}}
			class Keep{constructor(){this.string=defaultString;this.chord=null;this.result=[]}
				startChord(){this.chord=new ChordBuilder()}endChord(){this.chord=null}get chording(){return k.chord!=null}}
			let k=()=>new Keep()
			let parse=(k,[type,value])=>{
				let string=(a)=>{k.string=a;return k}
				let fret=(a)=>{k.result=k.result.concat(pluck(k.string,a));return k}
				let delay2=()=>{k.result=k.result.concat(delay());return k}
				let newLine2=()=>{k.result=k.result.concat(newLine());return k}
				switch(type){
					case char.string:return string(value)
					case char.fret:return fret(value)
					case char.delay:return delay2()
					case char.newLine:return newLine2()
					case char.startChord:return k.startChord()
					case char.endChord:return k.endChord()
					}
			}
			return a.reduce(parse,k()).result
		}
		let b=a.toLowerCase()
		let c=parseText(b)
		let e=reformatOmitContent2(c)
		return e
	}
	///ç”¨è°±å­æ•°æ®ç”ŸæˆHTMLæ ‡è®°
	let generateHTML=(a)=>{
		let pluck=(a)=>`<div class="pluck${a.string}${a.fret}">${a.fret}</div>`
		let delay=()=>`<div class="delay"></div>`
		let other=()=>`<div class="newLine"></div>`
		let generate=(a)=>a instanceof Pluck?pluck(a):a instanceof Delay?delay():other()
		let b=parse(a)
		let e=b.map(generate).join('')
		return e
	}
	onload=()=>{
		let i= document.getElementsByTagName('textarea')[0]
		let o=document.getElementsByTagName("div")[0]
		let output=(a)=>o.innerHTML=a
		let draw=()=>output(generateHTML(i.value))
		i.oninput=function(){draw()}
		draw()
		i.focus()
		i.selectionStart=i.value.length
		//e.onpropertychange = e.oninput; // for IE8
		// e.onchange = e.oninput; // FF needs this in <select><option>...
	}
	//http://xahlee.info/comp/unicode_music_symbols.html
	//https://w3c.github.io/smufl/gitbook/tables/beamed-groups-of-notes.html
</script>
