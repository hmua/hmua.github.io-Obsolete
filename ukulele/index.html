
<style>
	textarea { width: 100% }
	.tabs { padding-left:.5em;font-family: 'Trebuchet MS'; margin:.5em auto;line-height: 1rem;letter-spacing: -.1em;
				 background:repeating-linear-gradient(
					 silver,silver.1em,transparent.1em,transparent 1em
					 ,silver 1em,silver 1.1em,transparent 1.1em,transparent 2em
					 ,silver 2em,silver 2.1em,transparent 2.1em,transparent 3em
					 ,silver 3em,silver 3.1em,transparent 3.1em,transparent 6em) 0 .45em
				 ,repeating-linear-gradient(90deg,whitesmoke,whitesmoke 1px,transparent 1px,transparent.8em) .11em
	}
		.tabs .newLine {margin-bottom:2em; margin-right: 100% }
		.tabs .pluck,.tabs .delay { width: .8rem; text-align:center; display: inline-block;
			 vertical-align: middle;/*å¦‚æœä¸è®¾ç½®è¿™æ¡ï¼Œç”¨paddingè®¾ç½®ç«–å‘ä½ç½®å°±ä¼šå¤±æ•ˆâ€¦â€¦æ„Ÿè§‰æ˜¯bugï¼ˆä½†è¿™ä¸å¯èƒ½å•Šâ€¦â€¦ï¼‰*/
			 text-shadow:
				 -.05em 0 white,.05em 0 white,0 -.05em white,0 .05em white
				 ,-.1em 0 white,.1em 0 white,0 -.1em white,0 .1em white}
		.tabs .pluck.g { margin: 3rem 0 0 }
		.tabs .pluck.c { margin: 2rem 0 1rem }
		.tabs .pluck.e { margin: 1rem 0 2rem }
		.tabs .pluck.a { margin: 0 0 3rem }
		.tabs .high{ font-size: .9em }
		.tabs .high::first-letter{ font-size: .8em;vertical-align:top }
		.tabs .chord { display: inline-flex; justify-content: flex-end; flex-direction: column;vertical-align: middle; }
			.tabs .chord .pluck { margin: 0 !important; }
		.tabs .overtone::before { content: "âƒŸ"; vertical-align: middle; margin-right: -.45rem;margin-left: .4rem; font-size: 1.5rem; color: silver;vertical-align:top;text-shadow:0;/*transform: rotateX(45deg)*/ }

	h1 { background: silver; padding: .5em }
		h1::before { content: 'ğŸ¼' }
	html { font-family: 'Microsoft YaHei UI' }
	textarea { height: 5em; font-size: .7em; font-family: Consolas }
	ol, ul { margin: .5rem }
</style>
<h1>æ–‡æœ¬è®°è°±ç”ŸæˆTABs</h1>
<div class="tabs"></div>
<textarea></textarea>
<ul>
	<li>Gã€Cã€Eã€Aè¡¨ç¤ºå¼¦å››åˆ°ä¸€ï¼Œæ•°å­—1åˆ°9è¡¨ç¤ºå“</li>
	<li>é”®ç›˜ç¬¬ä¸€è¡Œé™¤Eä¹‹å¤–çš„â€œQWRTYUIOPâ€è¡¨ç¤ºååŠä»¥ä¸Šå“</li>
	<li>ä¾‹å¦‚â€œG1â€è¡¨ç¤ºGå¼¦ä¸€å“ï¼Œâ€œC7â€è¡¨ç¤ºCå¼¦ä¸ƒå“</li>
	<li>â€œEQâ€Eå¼¦åå“ï¼Œâ€œA0â€Aå¼¦å¼€éŸ³ï¼Œç­‰ç­‰</li>
	<li>æŒ‰æ‹¨å¼¦é¡ºåºå†™</li>
	<li>é‡å¤å¼¦å¯ä»¥çœç•¥ï¼Œä¾‹å¦‚â€œA0077997â€ä¸ƒä¸ªéŸ³éƒ½æ˜¯Aå¼¦</li>
	<li>å¼€å¤´ä¸å†™åˆ™é»˜è®¤Aå¼¦</li>
	<li>ç”¨æ‹¬å·è¡¨ç¤ºå’Œå¼¦ï¼Œå°–æ‹¬å·è¡¨ç¤ºæ³›éŸ³</li>
	<li>ç©ºæ‹æˆ–è€…ä¼‘æ­¢ç”¨ç©ºæ ¼ï¼Œæ˜¾ç¤ºå‡ºæ¥ä¼šæŒ‰æ‹å­å¯¹é½</li>
</ul><ul>
	<li>ç ”å‘åˆæœŸï¼Œæ ¼å¼éšæ—¶è°ƒæ•´ï¼Œéšä¾¿è¯•ç”¨ä¸‹å°±å¥½</li>
	<li>å­—æ¯ä¸åŒºåˆ†å¤§å°å†™ï¼Œä»¥ååŠŸèƒ½å¤šäº†å¯èƒ½ä¼šåŒºåˆ†</li>
	<li>è®©è®°è°±å°½å¯èƒ½ç®€å•â€¦â€¦çœ‹è°±å°½å¯èƒ½æ–¹ä¾¿</li>
	<li>æ²¡æœ‰ä¿å­˜åŠŸèƒ½ï¼Œå¯ä»¥å¤åˆ¶å‡ºå»ä¿å­˜ï¼ˆæœªæ¥ä¼šæœ‰ï¼‰</li>
	<li>åªæ”¯æŒå°¤å…‹é‡Œé‡ŒGCEAè°ƒå¼¦ï¼Œæœªæ¥ä¼šæ”¯æŒå…¶å®ƒ</li>
	<li>å¯ä»¥ç”¨æµè§ˆå™¨çš„ç¼©æ”¾åŠŸèƒ½è°ƒæ•´åˆ°æ»¡æ„å¤§å°</li>
	<li>è¾“å…¥æ¡†ä¹Ÿå¯ä»¥æ‹–ä½å³ä¸‹è§’è°ƒæ•´å¤§å°</li>
	<li>å¥½çš„å°¤å…‹é‡Œé‡Œè°±ä¸æ˜¯æœºæ¢°å¼çš„è®°å½•æˆ–è½¬æ¢</li>
	<li>æ­¤å·¥å…·åªæ˜¯æ–¹ä¾¿åŸºæœ¬è®°å½•</li></ul>
<span style="color:red;">&#9833;</span>
<span style="color:orange;">&#9837;</span>
<span style="color:yellow;">&#9834;</span>
<span style="color:green;">&#9839;</span>
<span style="color:aqua;">&#9835;</span>
<span style="color:blue;">&#9838;</span>
<span style="color:purple;">&#9836;</span>
<script>
	class Pluck{constructor(string,fret){this.string=string;this.fret=fret}}let pluck=(string,fret)=>new Pluck(string,fret)
	class Overtone{constructor(string,fret){this.string=string;this.fret=fret}}let overtone=(string,fret)=>new Overtone(string,fret)
	class Chord{constructor(seq){this.seq=seq}get(){seq}}let chord=(a)=>new Chord(a)
	class Delay{}let delay=()=>new Delay()
	class NewLine{}let newLine=()=>new NewLine()
	let parse=(a)=>{
		let char={string:"string",fret:"fret",delay:"delay",newLine:"newLine",startChord:"startChord",endChord:"endChord"
			,startOvertone:"startOvertone",endOvertone:"endOvertone"}
		//TODOè¿™é‡Œæœ‰ä¸ªâ€¦â€¦é€»è¾‘æ¶æ„é—®é¢˜â€¦â€¦å¸Œæœ›èƒ½æŠŠâ€œæŠ˜è¡Œâ€ç•™åœ¨æ ‡è®°å’Œè¡¨ç°å±‚ï¼Œä¸å‘ä¸‹ä¼ åˆ°æ•°æ®ï¼Œæ€ä¹ˆåšåé¢è¦å°è¯•ä¸€ä¸‹
		///è¯†åˆ«ã€æ ‡è¯†ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬
		let mapText=(a)=>{
			let parseChar=(a)=>{
				let mismatch=Symbol()
				let fret=["0","1","2","3","4","5","6","7","8","9"].includes(a)?parseInt(a):
						a=="q"?10:a=="w"?11:a=="r"?12:a=="t"?13:a=="y"?14:a=="u"?15:a=="i"?16:a=="o"?17:a=="p"?18:mismatch
				let string=["g","c","e","a"].includes(a)?a:mismatch
				let startChord=a=="("?char.startChord:mismatch
				let endChord=a==")"?char.endChord:mismatch
				let startOvertone=a=="<"?char.startOvertone:mismatch
				let endOvertone=a==">"?char.endOvertone:mismatch
				let delay=a==" "?char.delay:mismatch
				let newLine=a=="\n"?char.newLine:mismatch
				//TODO JSæœ‰æ²¡æœ‰delay executeï¼Ÿï¼Ÿï¼Ÿæˆ–è€…å¯èƒ½æœ¬èº«å°±æ˜¯ï¼Ÿï¼Ÿæ™šäº›å†ç¡®è®¤â€¦â€¦
				return fret!=mismatch?[char.fret,fret]:string!=mismatch?[char.string,string]:
					startChord!=mismatch?[startChord]:endChord!=mismatch?[endChord]:
					startOvertone!=mismatch?[startOvertone]:endOvertone!=mismatch?[endOvertone]:
					delay!=mismatch?[delay]:newLine!=mismatch?[newLine]:null
			}
			return a.split('').map(parseChar)
		}
		let reformatOmitContent2=(a)=>{
			let defaultString="a"
			class ChordBuilder{constructor(){this.r=[]}
				setString(a){this.string=a}
				setFret(a){r.push[this.string,a]}
				get(){r}}
			class Keep{constructor(){this.string=defaultString;this.chord=null;this.result=[]}
				startChord(){this.chord=new ChordBuilder()}endChord(){this.chord=null}get chording(){return k.chord!=null}}
			let k=()=>new Keep()
			let parse=(k,[type,value])=>{
				let string=(a)=>{k.string=a;return k}
				let fret=(a)=>{k.result=k.result.concat(pluck(k.string,a));return k}
				let delay2=()=>{k.result=k.result.concat(delay());return k}
				let newLine2=()=>{k.result=k.result.concat(newLine());return k}
				switch(type){
					case char.string:return string(value)
					case char.fret:return fret(value)
					case char.delay:return delay2()
					case char.newLine:return newLine2()
					case char.startChord:return k.startChord()
					case char.endChord:return k.endChord()
				}
			}
			return a.reduce(parse,k()).result
		}
		let sort2=(a)=>{
			let defaultString="a"
			class ChordBuilder{constructor(){this.r=[]}
				setString(a){this.string=a}
				setFret(a){r.push[this.string,a]}
				get(){r}}
			class Keep{constructor(){this.string=defaultString;this.chord=null;this.result=[]}
				startChord(){this.chord=new ChordBuilder()}endChord(){this.chord=null}get chording(){return k.chord!=null}}
			let k=()=>new Keep()
			let plucks=(k,[type,value])=>{
				let string=(a)=>{k.string=a;return k}
				let fret=(a)=>{k.result=k.result.concat(pluck(k.string,a));return k}
				let delay2=()=>{k.result=k.result.concat(delay());return k}
				let newLine2=()=>{k.result=k.result.concat(newLine());return k}
				switch(type){
					case char.string:return string(value)
					case char.fret:return fret(value)
					case char.delay:return delay2()
					case char.newLine:return newLine2()
					default:return[type,value]
				}
			}
			return a.reduce(plucks,k()).result
		}
		let parse=(a)=>{
			///ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬æ”¯æŒçœç•¥é‡å¤å¼¦ï¼Œåœ¨è¿™é‡ŒæŠŠçœç•¥çš„å†…å®¹è¡¥å®Œæ•´
			let plucks=(a)=>{
				let defaultString="a"
				let p=([string,r],[type,value])=>
					type==char.string?[value,r]:
					type==char.fret?[string,r.concat(pluck(string,value))]:
					type==char.delay?[string,r.concat(delay())]:
					type==char.newLine?[string,r.concat(newLine())]:
					[string,r.concat(type)]
				let parse2=([string,r],[type,value])=>{
					switch(type){
						case char.string:return[value,r]
						case char.fret:return[string,r.concat(pluck(string,value))]
						case char.delay:return[string,r.concat(delay())]
						default:return[string,r.concat(newLine())]
						}}
				return a.reduce(p,[defaultString,[]])[1]
			}
			let chords=(a)=>{
				let p=([chord,r],a)=>{
					let start=()=>[[],r]
					let end=()=>[null,r.concat([chord])]
					let isPluck=()=>a instanceof Pluck
					let inChord=()=>chord!=null
					let addPluck=()=>[chord.concat(a),r]
					let copy=()=>[chord,r.concat([a])]
					return a==char.startChord?start():
						inChord()&&isPluck()?addPluck():
							a==char.endChord?end():
								copy()
					}
				return a.reduce(p,[null,[]])[1]
			}
			let overtones=(a)=>{
				let p=([isOvertone,r],a)=>{
					let start=()=>[true,r]
					let end=()=>[false,r]
					let add=()=>[isOvertone,r.concat(overtone(a.string,a.fret))]
					let copy=()=>[isOvertone,r.concat([a])]
					return a==char.startOvertone?start():
						a==char.endOvertone?end():
							isOvertone?add():
								copy()
					}
				return a.reduce(p,[false,[]])[1]
			}
			let b=plucks(a)
			let c=chords(b)
			let d=overtones(c)
			return d
		}
		let b=a.toLowerCase()
		let c=mapText(b)
		let e=parse(c)
		return e
	}
	///ç”¨è°±å­æ•°æ®ç”ŸæˆHTMLæ ‡è®°
	let generateHTML=(a)=>{
		let pluck=(a)=>`<div class="pluck ${a.string}${a.fret>=10?' high':''}">${a.fret}</div>`
		let overtone=(a)=>`<div class="overtone pluck ${a.string}${a.fret>=10?' high':''}">${a.fret}</div>`
		let chord=(a)=>{
			let o=["g", "c", "e","a"].reverse()
			a.sort((a,b)=>o.indexOf(a.string)-o.indexOf(b.string))
			return`<div class="chord">`+a.map(pluck).join('')+`</div>`
			}
		let delay=()=>`<div class="delay"></div>`
		let other=()=>`<div class="newLine"></div>`
		let generate=(a)=>
			a instanceof Pluck?pluck(a):
				a instanceof Array?chord(a):
					a instanceof Overtone?overtone(a):
						a instanceof Delay?delay():other()
		let b=parse(a)
		let e=b.map(generate).join('')
		return e
	}
	let test="c2e3a02c0e0a2230e3a0c0e2a0 &#x00A;c2e23a0c2e2a002 \ng1c2(g1c2e3a4)e3a4\nc0123e45a6789qwrtyuiop"
	let halili="G0 A3 (G0C0E0A5) G0 A653 (G0C0E0A3) C0 G0 A3 (G0C4E5A5) C<R> A5 E<R> A7 C0 \nG0 A0 (G0C5E5A7) C5 A7 8 (G0C5E5A5)7G0E8 A0G0 (G0C5E4A7) E4 A7 5 (G0C4E5A5)   \nG0 A3 (G0C0E0A5) G0 A653 (G0C0E0A3) C0 G0 A3 (G0C4E5A5) C<R> A5 E<R> A7 C0 \nG0 A0 (G0C5E5A5)78 575 (G0C2E3A3) C2 A2 (G0C0E3A3)5  (G0C0E3A3) (G0C0E3A3)   (G0C0E3A3)(G0C0E3A3) C<R>"
	onload=()=>{
		let i= document.getElementsByTagName('textarea')[0]
		let o=document.getElementsByTagName("div")[0]
		let output=(a)=>o.innerHTML=a
		let draw=()=>output(generateHTML(i.value))
		i.oninput=function(){draw()}
		i.value=halili
		draw()
		i.focus()
		i.selectionStart=i.value.length
		//e.onpropertychange = e.oninput; // for IE8
		// e.onchange = e.oninput; // FF needs this in <select><option>...
	}
	//JavaScriptè¯•ç”¨ä½“éªŒï¼ˆå’ŒF#æ¯”è¾ƒï¼‰
	//é¦–å…ˆâ€¦â€¦ä»£ç ç»“æ„çœŸçš„éå¸¸ä¸€è‡´å•Šâ€¦â€¦F#è¿™ä¸ªå‡è£…é«˜å¸…å¯Œçš„éª—çº¸ï¼
	//JSå†™èµ·æ¥éå¸¸é¡ºæ‰‹æœ‰æœ¨æœ‰ï¼Ÿè°ƒè¯•ä¹Ÿæ–¹ä¾¿åˆ°ä¸è¡Œ
	//ä½†JSæœ‰äº›ä¸çˆ½çš„åœ°æ–¹
		//é¦–å½“å…¶å†²å°±æ˜¯æœ¬åœ°å˜é‡ä¸èƒ½è¦†ç›–ä¸Šå±‚çš„ï¼Œå¿…é¡»å¾—åç§°ä¸ä¸€æ ·ï¼Œä¸ç„¶çš„è¯â€¦â€¦æŠ¥é”™è¿˜æ˜¯ä»¥å¤–å±‚å˜é‡ä¼˜å…ˆæ¥çš„â€¦â€¦å¿˜è®°äº†
		//å…¶æ¬¡â€¦â€¦å‡½æ•°æ˜¯é»˜è®¤recursiveï¼Œè¿™ç‚¹æ¥ä¸Šä¸€ç‚¹ï¼Œæœ¬åœ°å‡½æ•°è°ƒå¤–å±‚åŒåå‡½æ•°ç»“æœè°ƒçš„æ˜¯è‡ªå·±ï¼Œæ­»å¾ªç¯äº†OMGï¼
			//ä»¥ä¸Šä¸¤æ¡ä¹ˆâ€¦â€¦å˜é‡åçš„é—®é¢˜é€šè¿‡å¥—ä¸€å±‚æ¥è§£å†³ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿä¼¼ä¹ä¹Ÿä¸å¤§å®Œç¾â€¦â€¦
		//æ²¡æœ‰pipeï¼Œç»“æœè¦ä¹ˆå½±å“å¯è¯»æ€§ï¼Œå‘ƒâ€¦â€¦ä½†è¿™ä¹Ÿç®—æ˜¯æä¾›äº†æ›´å¤šç»†æ‹†å‡½æ•°è°ƒç”¨çš„åŠ¨åŠ›â€¦â€¦
		//å†™äº†ä¸€æ®µæ—¶é—´â€¦â€¦è¿˜æ˜¯æ„Ÿå—åˆ°äº†æ²¡æœ‰ç±»å‹æ£€æŸ¥çš„â€¦â€¦(O_O)
			//åªèƒ½è‡ªå·±æ£€æŸ¥å“ˆå“ˆâ€¦â€¦^_^è¿˜çœŸæ˜¯ä¸èƒ½å·æ‡’äº†
	//http://xahlee.info/comp/unicode_music_symbols.html
	//https://w3c.github.io/smufl/gitbook/tables/beamed-groups-of-notes.html
</script>
